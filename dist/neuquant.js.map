{"version":3,"file":"neuquant.js","mappings":"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","sources":["webpack://gif.js.turbo/webpack/universalModuleDefinition","webpack://gif.js.turbo/./src/NeuQuant.js","webpack://gif.js.turbo/webpack/bootstrap","webpack://gif.js.turbo/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/* NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994.\n * See \"Kohonen neural networks for optimal colour quantization\"\n * in \"Network: Computation in Neural Systems\" Vol. 5 (1994) pp 351-367.\n * for a discussion of the algorithm.\n * See also  http://members.ozemail.com.au/~dekker/NEUQUANT.HTML\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal\n * in this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons who receive\n * copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n *\n * (JavaScript port 2012 by Johan Nordberg)\n *\n * Micro-optimization\n *  Roman Viskin (npm@terikon.com)\n */\n\nfunction toInt(v) {\n  return ~~v;\n}\n\nvar ncycles = 100; // number of learning cycles\nvar netsize = 256; // number of colors used\nvar maxnetpos = netsize - 1;\n\n// defs for freq and bias\nvar netbiasshift = 4; // bias for colour values\nvar intbiasshift = 16; // bias for fractions\nvar intbias = (1 << intbiasshift);\nvar gammashift = 10;\nvar gamma = (1 << gammashift);\nvar betashift = 10;\nvar beta = (intbias >> betashift); /* beta = 1/1024 */\nvar betagamma = (intbias << (gammashift - betashift));\n\n// defs for decreasing radius factor\nvar initrad = (netsize >> 3); // for 256 cols, radius starts\nvar radiusbiasshift = 6; // at 32.0 biased by 6 bits\nvar radiusbias = (1 << radiusbiasshift);\nvar initradius = (initrad * radiusbias); //and decreases by a\nvar radiusdec = 30; // factor of 1/30 each cycle\n\n// defs for decreasing alpha factor\nvar alphabiasshift = 10; // alpha starts at 1.0\nvar initalpha = (1 << alphabiasshift);\nvar alphadec; // biased by 10 bits\n\n/* radbias and alpharadbias used for radpower calculation */\nvar radbiasshift = 8;\nvar radbias = (1 << radbiasshift);\nvar alpharadbshift = (alphabiasshift + radbiasshift);\nvar alpharadbias = (1 << alpharadbshift);\n\n// four primes near 500 - assume no image has a length so large that it is\n// divisible by all four primes\nvar prime1 = 499;\nvar prime2 = 491;\nvar prime3 = 487;\nvar prime4 = 503;\nvar minpicturebytes = (3 * prime4);\n\n/*\n  Constructor: NeuQuant\n\n  Arguments:\n\n  pixels - array of pixels in RGB format\n  samplefac - sampling factor 1 to 30 where lower is better quality\n\n  >\n  > pixels = [r, g, b, r, g, b, r, g, b, ..]\n  >\n*/\nfunction NeuQuant(pixels, samplefac, preserveIndexForTransparentPixel) {\n  if (preserveIndexForTransparentPixel) {\n    netsize -= 1;\n    maxnetpos -=1;\n  }\n\n  var network; // int[netsize][4]\n  var netindex; // for network lookup - really 256\n\n  // bias and freq arrays for learning\n  var bias;\n  var freq;\n  var radpower;\n\n  /*\n    Private Method: init\n\n    sets up arrays\n  */\n  function init() {\n    network = [];\n    netindex = [];\n    bias = [];\n    freq = [];\n    radpower = [];\n\n    var i, v;\n    for (i = 0; i < netsize; i++) {\n      v = (i << (netbiasshift + 8)) / netsize;\n      network[i] = [v, v, v];\n      freq[i] = intbias / netsize;\n      bias[i] = 0;\n    }\n  }\n\n  /*\n    Private Method: unbiasnet\n\n    unbiases network to give byte values 0..255 and record position i to prepare for sort\n  */\n  function unbiasnet() {\n    for (var i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; // record color number\n    }\n  }\n\n  /*\n    Private Method: altersingle\n\n    moves neuron *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function altersingle(alpha, i, b, g, r) {\n    network[i][0] -= (alpha * (network[i][0] - b)) / initalpha;\n    network[i][1] -= (alpha * (network[i][1] - g)) / initalpha;\n    network[i][2] -= (alpha * (network[i][2] - r)) / initalpha;\n  }\n\n  /*\n    Private Method: alterneigh\n\n    moves neurons in *radius* around index *i* towards biased (b,g,r) by factor *alpha*\n  */\n  function alterneigh(radius, i, b, g, r) {\n    var lo = Math.abs(i - radius);\n    var hi = Math.min(i + radius, netsize);\n\n    var j = i + 1;\n    var k = i - 1;\n    var m = 1;\n\n    var p, a;\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n\n      if (k > lo) {\n        p = network[k--];\n        p[0] -= (a * (p[0] - b)) / alpharadbias;\n        p[1] -= (a * (p[1] - g)) / alpharadbias;\n        p[2] -= (a * (p[2] - r)) / alpharadbias;\n      }\n    }\n  }\n\n  /*\n    Private Method: contest\n\n    searches for biased BGR values\n\n    should be heavily optimized\n  */\n  function contest(b, g, r) {\n    /*\n      finds closest neuron (min dist) and updates freq\n      finds best neuron (min dist-bias) and returns position\n      for frequently chosen neurons, freq[i] is high and bias[i] is negative\n      bias[i] = gamma * ((1 / netsize) - freq[i])\n    */\n\n    b = b | 0;\n    g = g | 0;\n    r = r | 0;\n\n    var bestd = ~(1 << 31);\n    var bestbiasd = bestd;\n    var bestpos = -1;\n    var bestbiaspos = bestpos;\n\n    var i, n, dist, biasdist, betafreq;\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n\n      dist = (Math.abs((n[0] | 0) - b) + Math.abs((n[1] | 0) - g) + Math.abs((n[2] | 0) - r)) | 0;\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i] | 0) >> (intbiasshift - netbiasshift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n\n    return bestbiaspos;\n  }\n\n  /*\n    Private Method: inxbuild\n\n    sorts network and builds netindex[0..255]\n  */\n  function inxbuild() {\n    var i, j, p, q, smallpos, smallval, previouscol = 0, startpos = 0;\n    for (i = 0; i < netsize; i++) {\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; // index on g\n      // find smallest in i..netsize-1\n      for (j = i + 1; j < netsize; j++) {\n        q = network[j];\n        if (q[1] < smallval) { // index on g\n          smallpos = j;\n          smallval = q[1]; // index on g\n        }\n      }\n      q = network[smallpos];\n      // swap p (i) and q (smallpos) entries\n      if (i != smallpos) {\n        j = q[0];   q[0] = p[0];   p[0] = j;\n        j = q[1];   q[1] = p[1];   p[1] = j;\n        j = q[2];   q[2] = p[2];   p[2] = j;\n        j = q[3];   q[3] = p[3];   p[3] = j;\n      }\n      // smallval entry is now in position i\n\n      if (smallval != previouscol) {\n        netindex[previouscol] = (startpos + i) >> 1;\n        for (j = previouscol + 1; j < smallval; j++)\n          netindex[j] = i;\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++)\n      netindex[j] = maxnetpos; // really 256\n  }\n\n  /*\n    Private Method: inxsearch\n\n    searches for BGR values 0..255 and returns a color index\n\n    should be heavily optimized\n  */\n  function inxsearch(b, g, r) {\n\n    b = b | 0;\n    g = g | 0;\n    r = r | 0;\n\n    var a, p, dist;\n\n    var bestd = 1000; // biggest possible dist is 256*3\n    var best = -1;\n\n    var i = netindex[g] | 0; // index on g\n    var j = i - 1; // start at netindex[g] and work outwards\n\n    while ((i < netsize) || (j >= 0)) {\n      if (i < netsize) {\n        p = network[i];\n        dist = (p[1] | 0) - g; // inx key\n        if (dist >= bestd) i = netsize; // stop iter\n        else {\n          i++;\n          if (dist < 0) dist = -dist;\n          a = (p[0] | 0) - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = (p[2] | 0) - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3] | 0;\n            }\n          }\n        }\n      }\n      if (j >= 0) {\n        p = network[j];\n        dist = g - (p[1] | 0); // inx key - reverse dif\n        if (dist >= bestd) j = -1; // stop iter\n        else {\n          j--;\n          if (dist < 0) dist = -dist;\n          a = (p[0] | 0) - b; if (a < 0) a = -a;\n          dist += a;\n          if (dist < bestd) {\n            a = (p[2] | 0) - r; if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3] | 0;\n            }\n          }\n        }\n      }\n    }\n\n    return best;\n  }\n\n  /*\n    Private Method: learn\n\n    \"Main Learning Loop\"\n  */\n  function learn() {\n    var i;\n\n    var lengthcount = pixels.length;\n    var alphadec = toInt(30 + ((samplefac - 1) / 3));\n    var samplepixels = toInt(lengthcount / (3 * samplefac));\n    var delta = toInt(samplepixels / ncycles);\n    var alpha = initalpha;\n    var radius = initradius;\n\n    var rad = radius >> radiusbiasshift;\n\n    if (rad <= 1) rad = 0;\n    for (i = 0; i < rad; i++)\n      radpower[i] = toInt(alpha * (((rad * rad - i * i) * radbias) / (rad * rad)));\n\n    var step;\n    if (lengthcount < minpicturebytes) {\n      samplefac = 1;\n      step = 3;\n    } else if ((lengthcount % prime1) !== 0) {\n      step = 3 * prime1;\n    } else if ((lengthcount % prime2) !== 0) {\n      step = 3 * prime2;\n    } else if ((lengthcount % prime3) !== 0)  {\n      step = 3 * prime3;\n    } else {\n      step = 3 * prime4;\n    }\n\n    var b, g, r, j;\n    var pix = 0; // current pixel\n\n    i = 0;\n    while (i < samplepixels) {\n      b = (pixels[pix] & 0xff) << netbiasshift;\n      g = (pixels[pix + 1] & 0xff) << netbiasshift;\n      r = (pixels[pix + 2] & 0xff) << netbiasshift;\n\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); // alter neighbours\n\n      pix += step;\n      if (pix >= lengthcount) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n        for (j = 0; j < rad; j++)\n          radpower[j] = toInt(alpha * (((rad * rad - j * j) * radbias) / (rad * rad)));\n      }\n    }\n  }\n\n  /*\n    Method: buildColormap\n\n    1. initializes network\n    2. trains it\n    3. removes misconceptions\n    4. builds colorindex\n  */\n  function buildColormap() {\n    init();\n    learn();\n    unbiasnet();\n    inxbuild();\n  }\n  this.buildColormap = buildColormap;\n\n  /*\n    Method: getColormap\n\n    builds colormap from the index\n\n    returns array in the format:\n\n    >\n    > [r, g, b, r, g, b, r, g, b, ..]\n    >\n  */\n  function getColormap() {\n    var map = [];\n    var index = [];\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n    return map;\n  }\n  this.getColormap = getColormap;\n\n  /*\n    Method: lookupRGB\n\n    looks for the closest *r*, *g*, *b* color in the map and\n    returns its index\n  */\n  this.lookupRGB = inxsearch;\n}\n\nmodule.exports = NeuQuant;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(22);\n"],"names":["root","factory","exports","module","define","amd","a","i","self","toInt","v","netsize","maxnetpos","initradius","initalpha","alpharadbias","alphabiasshift","pixels","samplefac","preserveIndexForTransparentPixel","network","netindex","bias","freq","radpower","altersingle","alpha","b","g","r","alterneigh","radius","p","lo","Math","abs","hi","min","j","k","m","contest","n","dist","biasdist","betafreq","bestd","bestbiasd","bestpos","bestbiaspos","intbiasshift","intbias","this","buildColormap","netbiasshift","init","step","lengthcount","length","alphadec","samplepixels","delta","rad","pix","learn","unbiasnet","q","smallpos","smallval","previouscol","startpos","inxbuild","getColormap","map","index","l","lookupRGB","best","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}